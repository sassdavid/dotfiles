#!/usr/bin/env bash
# bashsupport disable=BP5001,BP5006,BP5007,BP5008
# Install these dotfiles, run: ./install --help for help and examples.

set -o errexit

BOOTSTRAP_PATH="/tmp/sassdavid-dotfiles"
DOTFILES_PATH="${DOTFILES_PATH:-}"

if [ -f "${DOTFILES_PATH}/install-config" ]; then
  # shellcheck disable=SC1091
  . "${DOTFILES_PATH}/install-config"
elif [ -f "${BOOTSTRAP_PATH}/install-config" ]; then
  # shellcheck disable=SC1091
  . "${BOOTSTRAP_PATH}/install-config"
else
  # This happens on a first run that's not bootstrapped which is typically
  # the case when running tests in a container.

  # shellcheck disable=SC1091
  [ -f ./install-config ] && . ./install-config
fi

# Only run these when calling the script, not sourcing it.
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  SKIP_SYSTEM_PACKAGES="${1:-}"

  # Instead of cloning from a remote repo, files will get copied locally. This
  # is useful for testing in a container without committing anything.
  LOCAL="${LOCAL:-}"

  # This will get optionally populated later, it essentially does a git pull
  # to pull in the latest changes locally.
  PULL=

  # This will get optionally populated later, it combines pulling in the latest
  # updates and running the install script.
  PULL_UPDATE=

  DOTFILES_REPO_SLUG="${DOTFILES_REPO_SLUG:-sassdavid/dotfiles}"
  DOTFILES_CLONE_URL="${DOTFILES_CLONE_URL:-https://github.com/${DOTFILES_REPO_SLUG}}"
  DOTFILES_UPSTREAM_URL="${DOTFILES_UPSTREAM_URL:-https://github.com/sassdavid/dotfiles}"

  YOUR_NAME="${YOUR_NAME:-}"
  YOUR_EMAIL="${YOUR_EMAIL:-}"

  PACMAN_PACKAGES="${PACMAN_PACKAGES:-
    aspell
    base
    base-devel
    bc
    dnsutils
    btop
    curl
    ffmpeg
    fontconfig
    git
    gnupg
    inotify-tools
    keepassxc
    less
    man-db
    man-pages
    openbsd-netcat
    openssh
    pacman-contrib
    pwgen
    rsync
    tmux
    unzip
    wget
    whois
    wl-clipboard
    zip
    zsh
  }
  "
  PACMAN_PACKAGES_EXTRAS="${PACMAN_PACKAGES_EXTRAS:-}"

  APT_PACKAGES="${APT_PACKAGES:-
    aspell
    bc
    dnsutils
    btop
    build-essential
    curl
    ffmpeg
    fontconfig
    git
    gnupg
    inotify-tools
    iproute2
    keepassxc
    netcat-openbsd
    openssh-server
    pwgen
    rsync
    tmux
    unzip
    wget
    whois
    wl-clipboard
    xz-utils
    zip
    zsh
  }
  "
  APT_PACKAGES_EXTRAS="${APT_PACKAGES_EXTRAS:-}"

  BREW_PACKAGES="${BREW_PACKAGES:-
    aspell
    bash
    bc
    btop
    curl
    diffutils
    ffmpeg
    git
    gnupg
    pwgen
    rsync
    tmux
    wget
    xz
    zsh
  }
  "
  BREW_PACKAGES_EXTRAS="${BREW_PACKAGES_EXTRAS:-}"

  BREW_CASK_PACKAGES="${BREW_CASK_PACKAGES:-
    firefox
    ghostty
    google-chrome
    keepassxc
    maccy
  }
  "
  BREW_CASK_PACKAGES_EXTRAS="${BREW_CASK_PACKAGES_EXTRAS:-}"

  MISE_PACKAGES_ARCH="${MISE_PACKAGES_ARCH:-
    1password-cli
    amazon-ecr-credential-helper
    argocd
    awscli
    bat
    curlie
    delta
    dua
    eksctl
    eza
    fastfetch
    fd
    fzf
    gdu
    gitui
    golangci-lint
    helm
    hyperfine
    jq
    k9s
    kubectl
    maven
    neovim
    pre-commit
    ripgrep
    ruff
    shellcheck
    shfmt
    terraform
    terraform-docs
    terragrunt
    tflint
    trivy
    usage
    uv
    yq
    zoxide
  }
  "
  MISE_PACKAGES_ARCH_EXTRAS="${MISE_PACKAGES_ARCH_EXTRAS:-}"

  MISE_PACKAGES_DEBIAN="${MISE_PACKAGES_DEBIAN:-
    1password-cli
    amazon-ecr-credential-helper
    argocd
    awscli
    bat
    curlie
    delta
    dua
    eksctl
    eza
    fastfetch
    fd
    fzf
    gdu
    gitui
    golangci-lint
    helm
    hyperfine
    jq
    k9s
    kubectl
    maven
    neovim
    pre-commit
    ripgrep
    ruff
    shellcheck
    shfmt
    terraform
    terraform-docs
    terragrunt
    tflint
    trivy
    usage
    uv
    yq
    zoxide
  }
  "
  MISE_PACKAGES_DEBIAN_EXTRAS="${MISE_PACKAGES_DEBIAN_EXTRAS:-}"

  MISE_PACKAGES_MACOS="${MISE_PACKAGES_MACOS:-
    1password-cli
    amazon-ecr-credential-helper
    argocd
    awscli
    bat
    curlie
    delta
    dua
    eksctl
    eza
    fastfetch
    fd
    fzf
    gdu
    gitui
    golangci-lint
    helm
    hyperfine
    jq
    k9s
    kubectl
    maven
    neovim
    pre-commit
    ripgrep
    ruff
    shellcheck
    shfmt
    terraform
    terraform-docs
    terragrunt
    tflint
    trivy
    usage
    uv
    yq
    zoxide
  }
  "
  MISE_PACKAGES_MACOS_EXTRAS="${MISE_PACKAGES_MACOS_EXTRAS:-}"

  if [[ -z "${MISE_LANGUAGES[*]}" ]]; then
    declare -gA MISE_LANGUAGES
    MISE_LANGUAGES["node"]="node@22"
    MISE_LANGUAGES["python"]="python@3.13"
    MISE_LANGUAGES["go"]="go@latest"
    MISE_LANGUAGES["java"]="java@corretto-17"
  fi
  declare -A MISE_LANGUAGES_EXTRAS="${MISE_LANGUAGES_EXTRAS:-}"
fi

# We always want to determine these values no matter how this script is called.
CPU_ARCH="$(uname -m)"
OS_TYPE="$(uname | tr "[:upper:]" "[:lower:]")"
OS_DISTRO=
OS_IN_WSL=

C_RED="\e[0;31;1m"
C_GREEN="\e[0;32;1m"
C_CYAN="\e[0;36;1m"
C_RESET="\e[0m"

# -----------------------------------------------------------------------------
# Helper functions
# -----------------------------------------------------------------------------

_error() {
  local message="${1:-}"

  printf "%bERROR: %s%b\n\n" "${C_RED}" "${message}" "${C_RESET}" >&2
  exit 1
}

_info() {
  local message="${1:-}"
  printf "\n\n%b%s:%b\n\n" "${C_CYAN}" "${message}" "${C_RESET}"
}

_local_clone() {
  [ -z "${LOCAL}" ] && return 1

  # Extra protection to avoid clobbering real real dotfiles.
  if [ "${PWD}" != "${DOTFILES_PATH}" ]; then
    cp -R "${PWD}/." "${DOTFILES_PATH}"

    # Ensure the containerized environment starts fresh.
    if [ -n "${IN_CONTAINER}" ]; then
      # shellcheck disable=SC1091
      . ./install-config

      rm \
        "${DOTFILES_PATH}/.config/git/config.local" \
        "${DOTFILES_PATH}/.config/zsh/.aliases.local" \
        "${DOTFILES_PATH}/.config/zsh/.zprofile.local" \
        "${DOTFILES_PATH}/.config/zsh/.zsh_history" \
        "${DOTFILES_PATH}/.config/zsh/.zshrc.local"

      if grep -q "git@github.com:" "${DOTFILES_PATH}/.git/config"; then
        sed -i "s|git@github.com:|https://github.com/|g" "${DOTFILES_PATH}/.git/config"
      fi
    fi
  fi

  printf "They've been locally copied to '%s'\n" "${DOTFILES_PATH}"
}

_no_system_packages() {
  cat <<EOF
System package installation isn't supported with your distro (${OS_DISTRO})

Please install any comparable packages on your own, you can view the list at:

    https://github.com/sassdavid/dotfiles/blob/main/install

Then re-run this script and explicitly skip installing system packages:

    bash <(curl -sS https://raw.githubusercontent.com/sassdavid/dotfiles/main/install) --skip-system-packages
EOF

  exit 1
}

_install_packages_arch() {
  PACMAN_PACKAGES="$(echo "${PACMAN_PACKAGES}" | xargs)"

  if [[ -n "${PACMAN_PACKAGES}" || -n "${PACMAN_PACKAGES_EXTRAS}" ]]; then
    # shellcheck disable=SC2086
    sudo pacman -Syu --noconfirm ${PACMAN_PACKAGES} ${PACMAN_PACKAGES_EXTRAS}
  fi

  # Install Paru (AUR) if needed.
  if ! command -v paru >/dev/null 2>&1; then
    local paru_download_path="/tmp/paru-install"
    rm -rf "${paru_download_path}"
    git clone https://aur.archlinux.org/paru.git "${paru_download_path}"
    cd "${paru_download_path}" && makepkg --syncdeps --rmdeps --install --noconfirm && cd -
    rm -rf "${paru_download_path}"
  fi

  # Install Paru packages.
  AUR_PACKAGES="$(echo "${AUR_PACKAGES}" | xargs)"

  if [[ -n "${AUR_PACKAGES}" || -n "${AUR_PACKAGES_EXTRAS}" ]]; then
    # shellcheck disable=SC2086
    paru -Syu --noconfirm ${AUR_PACKAGES} ${AUR_PACKAGES_EXTRAS}
  fi

  # Install Mise packages.
  MISE_PACKAGES_ARCH="$(echo "${MISE_PACKAGES_ARCH}" | xargs)"
  echo
  # shellcheck disable=SC2086
  if [[ -n "${MISE_PACKAGES_ARCH}" || -n "${MISE_PACKAGES_ARCH_EXTRAS}" ]]; then
    mise use --global ${MISE_PACKAGES_ARCH} ${MISE_PACKAGES_ARCH_EXTRAS}
  fi
}

_install_packages_debian() {
  local ID=
  local ID_LIKE=

  # shellcheck disable=SC1091
  if [ -r /etc/os-release ]; then . /etc/os-release; fi

  if [ "$ID" = "ubuntu" ] || [[ "$ID_LIKE" =~ ubuntu ]]; then
    sudo apt-get update
    sudo apt-get install -y software-properties-common
    sudo add-apt-repository -y ppa:git-core/ppa
  fi

  APT_PACKAGES="$(echo "${APT_PACKAGES}" | xargs)"

  if [[ -n "${APT_PACKAGES}" || -n "${APT_PACKAGES_EXTRAS}" ]]; then
    # shellcheck disable=SC2086
    sudo apt-get update && sudo apt-get install -y ${APT_PACKAGES} ${APT_PACKAGES_EXTRAS}
  fi

  # Install Mise packages.
  #
  # Apt's packages typically have older versions since Debian and Ubuntu are
  # stable distros. In most cases the version included is fine but we do want
  # the latest and greatest versions for certain tools.
  MISE_PACKAGES_DEBIAN="$(echo "${MISE_PACKAGES_DEBIAN}" | xargs)"
  echo
  # shellcheck disable=SC2086
  if [[ -n "${MISE_PACKAGES_DEBIAN}" || -n "${MISE_PACKAGES_DEBIAN_EXTRAS}" ]]; then
    mise use --global ${MISE_PACKAGES_DEBIAN} ${MISE_PACKAGES_DEBIAN_EXTRAS}
  fi
}

_install_packages_macos() {
  local prefix="/opt/homebrew"
  [[ "${CPU_ARCH}" == "x86_64" ]] && prefix="/usr/local"

  # Ensure brew's paths are available for this script
  eval "$("${prefix}/bin/brew" shellenv)"

  BREW_PACKAGES="$(echo "${BREW_PACKAGES}" | xargs)"
  BREW_CASK_PACKAGES="$(echo "${BREW_CASK_PACKAGES}" | xargs)"

  if [[ -n "${BREW_PACKAGES}" || -n "${BREW_PACKAGES_EXTRAS}" ]]; then
    # shellcheck disable=SC2086
    brew install ${BREW_PACKAGES} ${BREW_PACKAGES_EXTRAS}
  fi

  if [[ -n "${BREW_CASK_PACKAGES}" || -n "${BREW_CASK_PACKAGES_EXTRAS}" ]]; then
    # shellcheck disable=SC2086
    brew install --cask ${BREW_CASK_PACKAGES} ${BREW_CASK_PACKAGES_EXTRAS}
  fi

  # Install Mise packages.
  MISE_PACKAGES_MACOS="$(echo "${MISE_PACKAGES_MACOS}" | xargs)"
  echo
  # shellcheck disable=SC2086
  if [[ -n "${MISE_PACKAGES_MACOS}" || -n "${MISE_PACKAGES_MACOS_EXTRAS}" ]]; then
    mise use --global ${MISE_PACKAGES_MACOS} ${MISE_PACKAGES_MACOS_EXTRAS}
  fi
}

_display_packages_output() {
  local packages="${1:-}"
  local packages_extras="${2:-}"
  local packages_aur="${3:-}"
  local packages_aur_extras="${4:-}"
  local mise="${5:-}"
  local mise_extras="${6:-}"

  if [ -n "${packages}" ]; then
    printf "\n:: Packages (default)\n"
    printf "%s" "${packages}"
  fi

  if [ -n "${packages_extras}" ]; then
    printf "\n:: Packages (extras)\n"
    printf "%s" "${packages_extras}"
  fi

  if [ -n "${packages_aur}" ]; then
    printf "\n:: Packages AUR (default)\n"
    printf "%s" "${packages_aur}"
  fi

  if [ -n "${packages_aur_extras}" ]; then
    printf "\n:: Packages AUR (extras)\n"
    printf "%s" "${packages_aur_extras}"
  fi

  if [ -n "${mise}" ]; then
    printf "\n:: Mise (default)\n"
    printf "%s" "${mise}"
  fi

  if [ -n "${mise_extras}" ]; then
    printf "\n:: Mise (extras)\n"
    printf "%s" "${mise_extras}"
  fi
}

_display_packages() {
  if [ "${OS_TYPE}" == "linux" ]; then
    if [ "${OS_DISTRO}" == "arch" ]; then
      _display_packages_output "${PACMAN_PACKAGES}" "${PACMAN_PACKAGES_EXTRAS}" \
        "${AUR_PACKAGES}" "${AUR_PACKAGES_EXTRAS}" \
        "${MISE_PACKAGES_ARCH}" "${MISE_PACKAGES_ARCH_EXTRAS}"
    elif [ "${OS_DISTRO}" == "debian" ]; then
      _display_packages_output "${APT_PACKAGES}" "${APT_PACKAGES_EXTRAS}" \
        "" "" \
        "${MISE_PACKAGES_DEBIAN}" "${MISE_PACKAGES_DEBIAN_EXTRAS}"
    fi
  else
    [ -n "${BREW_CASK_PACKAGES}" ] && BREW_PACKAGES+="${BREW_CASK_PACKAGES}"
    [ -n "${BREW_CASK_PACKAGES_EXTRAS}" ] && BREW_PACKAGES_EXTRAS+="${BREW_CASK_PACKAGES_EXTRAS}"

    _display_packages_output "${BREW_PACKAGES}" "${BREW_PACKAGES_EXTRAS}" \
      "" "" \
      "${MISE_PACKAGES_MACOS}" "${MISE_PACKAGES_MACOS_EXTRAS}"
  fi
}

# -----------------------------------------------------------------------------
# Main functions
# -----------------------------------------------------------------------------

bootstrap() {
  _info "BOOTSTRAP NEW INSTALLATION"

  rm -rf "${BOOTSTRAP_PATH}"
  mkdir -p "${BOOTSTRAP_PATH}"

  if [ -n "${LOCAL}" ]; then
    [ -n "${IN_CONTAINER}" ] && DOTFILES_PATH="/app"

    if [ -n "${DOTFILES_PATH}" ]; then
      cp "${DOTFILES_PATH}/install" "${BOOTSTRAP_PATH}/install"
      cp "${DOTFILES_PATH}/install-config.example" "${BOOTSTRAP_PATH}/install-config.example"
    else
      echo "LOCAL=1 cannot be used if DOTFILES_PATH is unset, aborting!" >&2
      exit 1
    fi
  else
    curl -sSL "https://raw.githubusercontent.com/${DOTFILES_REPO_SLUG}/main/install" \
      -o "${BOOTSTRAP_PATH}/install"
    curl -sSL "https://raw.githubusercontent.com/${DOTFILES_REPO_SLUG}/main/install-config.example" \
      -o "${BOOTSTRAP_PATH}/install-config.example"
  fi

  mv "${BOOTSTRAP_PATH}/install-config.example" "${BOOTSTRAP_PATH}/install-config"
  chmod +x "${BOOTSTRAP_PATH}/install"

  cat <<EOF
:: Welcome to ${DOTFILES_REPO_SLUG}!

Given this is your first run, a few temporary files were downloaded to
'/tmp/sassdavid-dotfiles' which is where you'll kick off running the install
script. It is set up this way so you have a chance to review a few config
values before running anything on your system.

We'll be deleting the above at the end so don't worry about the path.

:: Optionally view the install script's config file

cat ${BOOTSTRAP_PATH}/install-config

If you're ok with the list of packages and symlinks being created then you're
good to go to install these dotfiles. Feel free to edit the install-config file
beforehand if you want to make adjustments. The installed dotfiles will have
the same config file copied over which you can edit at any time.

:: Install these dotfiles

${BOOTSTRAP_PATH}/install

The above will re-run this script but instead of setting up temp files it will
walk you through picking where to install these dotfiles and install /
configure everything. From this point on you'll always be running the install
script from your dotfiles repo.

:: Delete the temporary directory

rm -rf ${BOOTSTRAP_PATH}

Once you've installed these dotfiles you can delete this temp directory.
EOF
}

detect_env() {
  case "${OS_TYPE}" in
  linux)
    if [ -r /etc/os-release ]; then
      # shellcheck disable=SC1091
      OS_DISTRO="$(. /etc/os-release && echo "${ID_LIKE:-${ID}}")"

      # Technically ID_LIKE can have a space separated list of distros but
      # we really only care that we have a Debian based system where apt is
      # available to use.
      [[ "${OS_DISTRO}" =~ (ubuntu|debian) ]] && OS_DISTRO="debian"
    fi

    # Only fully support these Linux distros.
    if [[ -z "${OS_DISTRO}" || ! "arch ubuntu debian raspbian" =~ ${OS_DISTRO} ]]; then
      [ -z "${SKIP_SYSTEM_PACKAGES}" ] && _no_system_packages
    fi

    # Are we in WSL?
    if grep -q "\-WSL2" /proc/version; then
      OS_IN_WSL=1
    fi

    ;;
  darwin) ;;
  *)
    _error "'${OS_TYPE}' is not supported"

    ;;
  esac
}

warn_root() {
  # Root will have an effective uid of 0, but it's ok if we're in a container.
  [[ "${EUID}" != 0 || -n "${IN_CONTAINER}" ]] && return 0

  cat <<EOF
Here are details about this user:

$(id)

EOF

  local msg="as root"
  [[ -n "${SUDO_USER}" ]] && msg="with sudo as ${SUDO_USER}"

  while true; do
    read -rp "This script is meant to run as a non-root user, are you sure you want to run this ${msg}? (y/n) " yn
    case "${yn}" in
    [Yy]*) break ;;
    [Nn]*) exit ;;
    *) printf "Please answer y or n\n\n" ;;
    esac
  done
}

check_prereqs() {
  _info "CHECKING SYSTEM COMPATABILITY"

  local missing_packages=()

  if ! command -v "sudo" 1>/dev/null; then missing_packages+=("sudo"); fi

  if [[ -z "${missing_packages[*]}" ]]; then
    echo "Everything is good to go"
    return 0
  fi

  cat <<EOF
This script is going to switch to the root user to install sudo then the rest
of the script will run as your user and use sudo as needed.

EOF

  case "${OS_DISTRO}" in
  arch)
    su -c "pacman -Syu --noconfirm ${missing_packages[*]}"
    ;;
  debian)
    su -c "apt-get update && apt-get install -y ${missing_packages[*]}"
    ;;
  *) ;;
  esac
}

create_initial_dirs() {
  mkdir -p \
    "${HOME}/.cache/zsh" \
    "${HOME}/.config/btop/themes" \
    "${HOME}/.config/fzf" \
    "${HOME}/.config/ghostty" \
    "${HOME}/.config/git" \
    "${HOME}/.config/gitui" \
    "${HOME}/.config/tmux/plugins" \
    "${HOME}/.config/zsh" \
    "${HOME}/.local/bin" \
    "${HOME}/.local/share/fonts"

  mkdir -p \
    "${HOME}/.config/eza" \
    "${HOME}/.local/share/zsh/completions" \
    "${HOME}/.aws"

  if [ -z "${GNUPGHOME}" ]; then
    # bashsupport disable=BP2001
    export GNUPGHOME="${XDG_CONFIG_HOME:-"${HOME}/.config"}/gnupg"
  fi

  mkdir -p "${GNUPGHOME}"
  chmod 700 "${GNUPGHOME}"
}

install_packages() {
  _info "INSTALL PACKAGES"

  if [ -n "${SKIP_SYSTEM_PACKAGES}" ]; then
    echo "Skipping, you've chosen not to or your distro isn't fully supported"
    return
  fi

  cat <<EOF
If you choose y, all of the system packages below will be installed:

$(_display_packages)


If you choose no, the above packages will not be installed and this script
will exit. This gives you a chance to edit the list of packages.

EOF

  printf "You can edit 'install-config' to modify the package list.\n\n"

  while true; do
    read -rp "Do you want to install the above packages? (y/n) " yn
    case "${yn}" in
    [Yy]*)
      if [ "${OS_TYPE}" == "linux" ]; then
        if [ "${OS_DISTRO}" == "arch" ]; then
          _install_packages_arch
        elif [ "${OS_DISTRO}" == "debian" ]; then
          _install_packages_debian
        fi
      else
        _install_packages_macos
      fi

      break
      ;;
    [Nn]*) exit ;;
    *) printf "Please answer y or n\n\n" ;;
    esac
  done
}

update_dotfiles() {
  _info "UPDATE DOTFILES"

  if [ -z "${DOTFILES_PATH:-}" ]; then
    echo "Skipping, since this is the first time you've run this script"
    return 0
  fi

  if [[ -z "${PULL}" && -z "${PULL_UPDATE}" ]]; then
    echo "Skipping, rerun with --pull or --update to get the latest changes"
    return 0
  fi

  if [ -n "${LOCAL}" ]; then
    echo "Skipping, since LOCAL=1 is set we'll avoid remote updates"
    return 0
  fi

  git -C "${DOTFILES_PATH}" fetch origin

  local new_commit_count=
  new_commit_count="$(git -C "${DOTFILES_PATH}" rev-list ..origin --count)"

  if [ "${new_commit_count}" = "0" ]; then
    echo "Skipping, since your local dotfiles already have the latest updates"
  else
    # Let's merge the latest updates.
    git -C "${DOTFILES_PATH}" merge origin

  [ -f "${DOTFILES_PATH}/install-config" ] || cp "${DOTFILES_PATH}/install-config.example" "${DOTFILES_PATH}/install-config"

    # Re-run this script because if an update happened, it's possible new
    # configuration was introduced which means reading in their env vars.
    exec "${0}" "${@}"
  fi
}

clone_dotfiles() {
  _info "CLONE DOTFILES"

  if [ -d "${DOTFILES_PATH:-}" ]; then
    echo "Skipping, since DOTFILES_PATH already exists at '${DOTFILES_PATH}'"
    return 0
  fi

  local dotfiles_path
  local default_dotfiles_path="${HOME}/src/github/dotfiles"

  read -rep "Where do you want to clone these dotfiles to [${default_dotfiles_path}]? " dotfiles_path
  echo

  [[ -z "${dotfiles_path}" ]] && dotfiles_path="${default_dotfiles_path}"

  DOTFILES_PATH="${dotfiles_path//\~/"${HOME}"}"

  _local_clone && return 0

  git clone "${DOTFILES_CLONE_URL}" "${DOTFILES_PATH}"
  git -C "${DOTFILES_PATH}" remote | grep -qw upstream ||
    git -C "${DOTFILES_PATH}" remote add upstream "${DOTFILES_UPSTREAM_URL}.git"

  # Carry over the bootstrapped config if it exists, but have a fallback plan.
  cp "${BOOTSTRAP_PATH}/install-config" "${DOTFILES_PATH}/install-config" 2>/dev/null || true
  [ -f "${DOTFILES_PATH}/install-config" ] || cp "${DOTFILES_PATH}/install-config.example" "${DOTFILES_PATH}/install-config"
}

install_fonts() {
  _info "INSTALL FONTS"

  local font_url="https://github.com/ryanoasis/nerd-fonts/releases/latest/download/JetbrainsMono.zip"
  local font_tmp="/tmp/jetbrainsmono"
  local font_zip="/tmp/jetbrainsmono.zip"
  local font_filename="JetBrainsMonoNerdFontMono-Regular.ttf"
  local windows_font_path="/mnt/c/Windows/Fonts"
  local macos_font_path="${HOME}/Library/Fonts"
  local linux_font_path="${XDG_DATA_HOME:-"${HOME}/.local/share"}/fonts"
  local font_path=
  local font_is_installed=

  if [ "${OS_TYPE}" = "linux" ]; then
    font_path="${linux_font_path}"

    if [ -n "${OS_IN_WSL}" ]; then
      font_path="${windows_font_path}"
    fi
  else
    font_path="${macos_font_path}"
  fi

  [ -f "${font_path}/${font_filename}" ] && font_is_installed=1

  if [ -n "${font_is_installed}" ]; then
    echo "Skipping, since fonts are already installed at '${font_path}'"
  else
    rm -rf "${font_zip}" "${font_tmp}"
    curl -sSL "${font_url}" -o "${font_zip}"
    unzip "${font_zip}" -d "${font_tmp}"

    if [ -n "${OS_IN_WSL}" ]; then
      cat <<EOF

Since we're in WSL 2 and we need to install Windows fonts, please do it manually.

Most of it has been automated for you, from within WSL 2 perform these steps:

1. cd ${font_tmp}
2. explorer.exe .
3. Right click the fonts and INSTALL FOR ALL USERS
4. rm -rf "${font_zip}" "${font_tmp}"

It's important step 3 is for all users not your personal user. It's also
important step 4 is executed so this script doesn't always download the font's
zip file and extract it to step 1.
EOF

      return 0
    fi

    cp "${font_tmp}"/JetBrainsMonoNerdFont*.ttf "${font_path}"
    cp "${font_tmp}"/JetBrainsMonoNLNerdFont*.ttf "${font_path}"

    # Update font cache on native Linux.
    [[ "${OS_TYPE}" = "linux" ]] && fc-cache -fv

    rm -rf "${font_zip}" "${font_tmp}"
  fi
}

install_zsh_plugins() {
  _info "INSTALL ZSH PLUGINS"

  "${DOTFILES_PATH}/.local/bin/dot-update-zsh-plugins"
}

create_symlinks() {
  _info "CREATE SYMLINKS"

  local symlinks=()
  local symlinks_wsl=()
  local symlinks_arch=()

  [ -n "${SYMLINKS[*]}" ] && symlinks+=("${SYMLINKS[@]}")
  [ -n "${SYMLINKS_EXTRAS[*]}" ] && symlinks+=("${SYMLINKS_EXTRAS[@]}")

  [ -n "${SYMLINKS_WSL[*]}" ] && symlinks_wsl+=("${SYMLINKS_WSL[@]}")
  [ -n "${SYMLINKS_WSL_EXTRAS[*]}" ] && symlinks_wsl+=("${SYMLINKS_WSL_EXTRAS[@]}")

  [ -n "${SYMLINKS_ARCH[*]}" ] && symlinks_arch+=("${SYMLINKS_ARCH[@]}")
  [ -n "${SYMLINKS_ARCH_EXTRAS[*]}" ] && symlinks_arch+=("${SYMLINKS_ARCH_EXTRAS[@]}")

  printf -- "-------------------------------------------------------------------------------\n"

  if [ -n "${symlinks[*]}" ]; then
    printf "\nSymlinks:\n"
    local link
    for link in "${symlinks[@]}"; do
      echo "  ${link}"
    done
  fi

  if [[ -n "${OS_IN_WSL}" && -n "${symlinks_wsl[*]}" ]]; then
    local windows_user=

    # shellcheck disable=SC2016
    windows_user="$({ for p in pwsh.exe '/mnt/c/Program Files/PowerShell/7/pwsh.exe' '/c/Program Files/PowerShell/7/pwsh.exe'; do if command -v "$p" >/dev/null 2>&1 || [ -x "$p" ]; then "$p" -NoProfile -NoLogo -Command '$env:UserName'; break; fi; done; } 2>/dev/null | tr -d '\r\n')"

    printf "\nSymlinks (WSL):\n"
    for link in "${symlinks_wsl[@]}"; do
      echo "  ${link//%WindowsUser/${windows_user}}"
    done
  fi

  if [[ "${OS_DISTRO}" = "arch" && -n "${symlinks_arch[*]}" ]]; then
    # It's a bit more complicated to extract this into a variable since it has
    # a condition with a fallback. For now let's keep it hard coded until a
    # better pattern arrises to handle this in a dynamic way.
    if [ -f "etc/pacman.d/02-ignore.conf" ]; then
      symlinks_arch+=("sudo ln -fns \"${DOTFILES_PATH}/etc/pacman.d/02-ignore.conf\" \"/etc/pacman.d/02-ignore.conf\"")
    else
      sudo rm -f "/etc/pacman.d/02-ignore.conf"
    fi

    printf "\nSymlinks (Arch):\n"
    for link in "${symlinks_arch[@]}"; do
      echo "  ${link}"
    done
  fi

  cat <<EOF

-------------------------------------------------------------------------------

A potentially destructive action is about to happen. The above directories and
files are going to get forcefully symlinked if you type y in the prompt below.

What does that mean?

Any config files you have on the right hand side of the paths are going to get
overwritten with the files that come with these dotfiles (left side).

Without these symlinks, these dotfiles will not work as is. If you plan to
type y and have existing files now would be a good time to back them up.

EOF

  while true; do
    read -rep "Ready to continue? Enter y to apply them all or n to skip (y/n) " yn
    case "${yn}" in
    [Yy]*)
      # Avoid using ln -T flag since it doesn't exist on macOS. We're being
      # extra careful here to only delete symlinks if they exist. Technically
      # rm -f would work but that could delete real files potentially.
      [ -L "${HOME}/.config/nvim" ] && rm "${HOME}/.config/nvim"

      if [ -n "${symlinks[*]}" ]; then
        for link in "${symlinks[@]}"; do
          eval "${link}"
        done
      fi

      if [[ -n "${OS_IN_WSL}" && -n "${symlinks_wsl[*]}" ]]; then
        for link in "${symlinks_wsl[@]}"; do
          eval "${link//%WindowsUser/${windows_user}}"
        done
      fi

      if [ "${OS_DISTRO}" = "arch" ]; then
        for link in "${symlinks_arch[@]}"; do
          eval "${link}"
        done
      fi

      break
      ;;
    [Nn]*)

      break
      ;;
    *) echo "Please answer y or n" ;;
    esac
  done
}

configure_system_configs() {
  _info "CONFIGURE SYSTEM CONFIGS"

  if [ "${OS_DISTRO}" = "arch" ]; then
    local etc_pacman_conf_path="/etc/pacman.conf"
    if ! grep -q "Include = /etc/pacman\.d/\*\.conf" "${etc_pacman_conf_path}" 2>/dev/null; then
      printf "\nInclude = /etc/pacman.d/*.conf\n" | sudo tee --append "${etc_pacman_conf_path}" 1>/dev/null
    fi
  fi

  echo "Everything that required updating was updated"
}

configure_home_configs() {
  _info "CONFIGURE HOME CONFIGS"

  local ghostty_config="${HOME}/.config/ghostty/config.local"

  if [ ! -f "${ghostty_config}" ]; then
    printf "# Add your custom overrides here, such as fonts, etc..\n" >"${ghostty_config}"
  fi

  echo "Everything that required updating was updated"
}

configure_shell() {
  _info "CONFIGURE SHELL (ZSH)"

  local local_files=(".zshrc.local" ".zprofile.local" ".aliases.local")
  local original_dotfiles_path="${DOTFILES_PATH}"

  local file
  for file in "${local_files[@]}"; do
    local file_path="${HOME}/.config/zsh/${file}"

    if [ ! -f "${file_path}" ]; then
      printf "# shellcheck shell=bash\n\n# Any settings defined here are gitignored.\n" >"${file_path}"
    fi
  done

  local zprofile_path="${DOTFILES_PATH}/.config/zsh/.zprofile.local"
  local aliases_path="${DOTFILES_PATH}/.config/zsh/.aliases.local"

  if ! grep -q "^export DOTFILES_PATH=.*$" "${zprofile_path}" 2>/dev/null; then
    printf '\nexport DOTFILES_PATH="%s"\n' "${DOTFILES_PATH}" >>"${zprofile_path}"
  fi

  if [ "${OS_TYPE}" == "darwin" ]; then
    if ! grep -q "HOMEBREW_NO_ANALYTICS" "${zprofile_path}" 2>/dev/null; then
      printf '\nexport HOMEBREW_NO_ANALYTICS=1\n' >>"${zprofile_path}"
    fi

    if ! grep -q "eval.*homebrew.*shellenv" "${zprofile_path}" 2>/dev/null; then
      local prefix="/opt/homebrew"
      [[ "${CPU_ARCH}" == "x86_64" ]] && prefix="/usr/local"

      # shellcheck disable=SC2016
      printf "\neval \"\$(%s/bin/brew shellenv)\"\n" "${prefix}" >>"${zprofile_path}"
    fi
  else
    # Are we in WSL 2?
    if [ -n "${OS_IN_WSL}" ]; then
      if ! grep -q "^export GIT_SSH=.*$" "${zprofile_path}" 2>/dev/null; then
        local git_ssh_env_config
        git_ssh_env_config=$(
          cat <<'EOF'
# Configure OpenSSH in order to 1password ssh agent will be usable
export GIT_SSH="/mnt/c/Program\ Files/OpenSSH/ssh.exe"
export GIT_SSH_COMMAND="/mnt/c/Program\ Files/OpenSSH/ssh.exe"
EOF
        )

        printf "\n%s" "${git_ssh_env_config}" >>"${zprofile_path}"
      fi

      if ! grep -q "^alias ssh=.*$" "${aliases_path}" 2>/dev/null; then
        local custom_aliases
        custom_aliases=$(
          cat <<'EOF'
# Configure OpenSSH in order to 1password ssh agent will be usable
alias ssh="/mnt/c/Program\ Files/OpenSSH/ssh.exe"
alias ssh-add="/mnt/c/Program\ Files/OpenSSH/ssh-add.exe"
alias scp="/mnt/c/Program\ Files/OpenSSH/scp.exe"

alias ssh2="/usr/bin/ssh"

# This is specific to WSL 2. If the WSL 2 VM goes rogue and decides not to free
# up memory, this command will free your memory after about 20-30 seconds.
#   Details: https://github.com/microsoft/WSL/issues/4166#issuecomment-628493643
alias drop_cache="sudo sh -c \"echo 3 >'/proc/sys/vm/drop_caches' && swapoff -a && swapon -a && printf '\n%s\n' 'Ram-cache and Swap Cleared'\""
EOF
        )

        printf "\n%s" "${custom_aliases}" >>"${aliases_path}"
      fi
    fi
  fi

  # Switch to zsh in a way that supports our supported OS and distros.
  local shell_path=
  shell_path="$(command -v zsh)"

  if ! grep -q "${shell_path}" /etc/shells; then
    echo "${shell_path}" | sudo tee -a /etc/shells 1>/dev/null
  fi

  [ "${SHELL: -3}" != "zsh" ] && chsh -s "${shell_path}"

  # shellcheck disable=SC1091
  . "${HOME}/.config/zsh/.zprofile"

  # Given the above line sets this env var if it's defined, this ensures we
  # always use the value that was set when running this script. This is mainly
  # to make testing this script easier in Docker since the .local files are
  # volume mounted and this value will be different in Docker.
  DOTFILES_PATH="${original_dotfiles_path}"

  echo "It has been configured in '${HOME}/.config/zsh/'"
}

ask_for_name() {
  _info "ASKING FOR YOUR NAME TO CONFIGURE GIT"

  local name=

  set +o errexit
  name="$(git config user.name)"
  set -o errexit

  if [[ -n "${name}" ]]; then
    echo "Skipping, since '${name}' was retrieved from your git config"
  else
    [ -n "${YOUR_NAME}" ] &&
      echo "Skipping, since '${YOUR_NAME}' was retrieved from your install config" &&
      return 0

    while true; do
      printf "What is your full name (ie. Dade Murphy)? "
      read -r name

      if [[ ${name} =~ [^[:space:]]+ ]]; then
        break
      else
        printf "Please enter at least your first name\n\n"
      fi
    done
  fi

  YOUR_NAME="${name}"
}

ask_for_email() {
  _info "ASKING FOR YOUR EMAIL TO CONFIGURE GIT"

  local email=

  set +o errexit
  email="$(git config user.email)"
  set -o errexit

  if [[ -n "${email}" ]]; then
    echo "Skipping, since '${email}' was retrieved from your git config"
  else
    [ -n "${YOUR_EMAIL}" ] &&
      echo "Skipping, since '${YOUR_EMAIL}' was retrieved from your install config" &&
      return 0

    while true; do
      printf "What is your email address (ie. zerocool@example.com)? "
      read -r email

      if [[ ${email} =~ .+@.+ ]]; then
        break
      else
        printf "Please enter a valid email address\n\n"
      fi
    done
  fi

  YOUR_EMAIL="${email}"
}

configure_git() {
  _info "CONFIGURE GIT"

  local config_dir="${DOTFILES_PATH}/.config/git"

  # Identities to generate. Add/remove entries as needed.
  local -a identities=(personal bitbucket work)

  local windows_user=
  # shellcheck disable=SC2016
  windows_user="$({ for p in pwsh.exe '/mnt/c/Program Files/PowerShell/7/pwsh.exe' '/c/Program Files/PowerShell/7/pwsh.exe'; do if command -v "$p" >/dev/null 2>&1 || [ -x "$p" ]; then "$p" -NoProfile -NoLogo -Command '$env:UserName'; break; fi; done; } | tr -d '\r\n')"

  local identity path
  for identity in "${identities[@]}"; do
    path="${config_dir}/config.user.${identity}"

    if [ -f "${path}" ]; then
      printf "Skipped %s (already exists)\n" "${path}"
      continue
    fi

    # Clear previous values so each identity is prompted
    unset YOUR_NAME YOUR_EMAIL

    # Log current identity being configured
    printf "\nCONFIGURING '%s'\n" "${identity^^}"

    ask_for_name
    ask_for_email

    cat >"${path}" <<EOF
[user]
  name = ${YOUR_NAME}
  email = ${YOUR_EMAIL}
  # Uncomment the options below to auto-sign your git commits / tags using SSH.
  #signingkey = ${YOUR_EMAIL}

#[commit]
#  gpgsign = true

# This option requires git 2.23+ to work and you must annotate your tags,
# although -m "" works if you want an empty message.
#[tag]
#  gpgSign = true

#[gpg]
#  format = ssh

#[gpg "ssh"]
#  program = "/mnt/c/Users/${windows_user}/AppData/Local/1Password/app/8/op-ssh-sign-wsl"

#[delta]
  # If you prefer side by side diffs, uncomment this.
  #side-by-side = true
EOF

    printf "Created %s\n" "${path}"
  done

  # Configure gitalias
  curl -fsSL https://raw.githubusercontent.com/GitAlias/gitalias/main/gitalias.txt \
    --create-dirs -o "${HOME}/.config/gitalias/gitalias.txt"

  printf "\ngitalias configured\n"
}

install_rust() {
  export RUST_LANG_HOME="${RUST_LANG_HOME:-"${HOME}/rust-lang"}"
  export RUSTUP_HOME="${RUSTUP_HOME:-"${RUST_LANG_HOME}/.rustup"}"
  export CARGO_HOME="${CARGO_HOME:-"${RUST_LANG_HOME}/.cargo"}"

  local rustup_bin
  rustup_bin="$(command -v rustup || true)"
  if [ -z "${rustup_bin}" ]; then
    rustup_bin="${CARGO_HOME}/bin/rustup"
  fi

  # Install rustup if not already installed
  if [ ! -x "${rustup_bin}" ]; then
    printf "\n\nRust not found, installing to %s...\n\n" "${RUST_LANG_HOME}"
    curl --proto '=https' --tlsv1.2 -fsSL https://sh.rustup.rs | sh -s -- -y --no-modify-path
    rustup_bin="${CARGO_HOME}/bin/rustup"
  else
    printf "\n\nRust already installed, updating...\n\n"
    "${rustup_bin}" self update
    "${rustup_bin}" update
  fi

  "${rustup_bin}" completions zsh >"${HOME}/.local/share/zsh/completions/_rustup"
  "${rustup_bin}" completions zsh cargo >"${HOME}/.local/share/zsh/completions/_cargo"
}

install_programming_languages() {
  _info "INSTALL PROGRAMMING LANGUAGES"

  local lang
  for lang in "${!MISE_LANGUAGES[@]}"; do
    [[ "${lang}" = "0" || -z "${MISE_LANGUAGES[${lang}]}" ]] && continue

    printf "\nInstalling %s...\n\n" "${MISE_LANGUAGES[${lang}]}"
    if command -v "${HOME}/.local/share/mise/shims/${lang}" 1>/dev/null; then
      echo "Skipping, it's already installed, run 'mise upgrade ${lang} --bump' to upgrade"
    else
      mise use --global "${MISE_LANGUAGES[${lang}]}"
    fi
  done

  for lang in "${!MISE_LANGUAGES_EXTRAS[@]}"; do
    [ -z "${MISE_LANGUAGES_EXTRAS[${lang}]}" ] && continue

    printf "\nInstalling %s...\n\n" "${MISE_LANGUAGES_EXTRAS[${lang}]}"
    if command -v "${HOME}/.local/share/mise/shims/${lang}" 1>/dev/null; then
      echo "Skipping, it's already installed, run 'mise upgrade ${lang} --bump' to upgrade"
    else
      mise use --global "${MISE_LANGUAGES_EXTRAS[${lang}]}"
    fi
  done

  install_rust
}

install_tmux_plugins() {
  _info "INSTALL TMUX PLUGINS"

  local plugin_path="${HOME}/.config/tmux/plugins"
  local tpm_path="${plugin_path}/tpm"

  rm -rf "${tpm_path}"
  git clone --depth 1 https://github.com/tmux-plugins/tpm "${tpm_path}"

  "${tpm_path}/bin/install_plugins"
}

install_nvim_plugins() {
  _info "INSTALL NEOVIM PLUGINS"

  mise x neovim -- nvim +q

  echo "They've been installed"
}

set_theme() {
  # Default to this theme as a fallback.
  local theme="gruvbox-dark-medium"

  local active_theme=
  local theme_changed=

  _info "SETTING THEME"

  # Extract the theme name from the symlink path, ie. tokyonight-moon.
  # There are scenarios (first run, etc.) where this will be empty in which
  # case it being undefined is ok.
  if [ -f "${HOME}/.config/fzf/theme.sh" ]; then
    active_theme="$(readlink "${HOME}/.config/fzf/theme.sh")"
    active_theme="$(dirname "${active_theme}")"
    active_theme="$(basename "${active_theme##*/}")"
  fi

  if [[ -n "${1}" ]]; then
    # This is when the dot-theme-set script gets run. Even if a random theme
    # is picked by supplying no argument, $1 is always set from that script.
    theme="${1}"
  else
    # We only want to do this if an active_theme was found, else we'll use the
    # fallback theme that was set at the top of the function.
    if [ -n "${active_theme}" ]; then
      # This is when a user runs this install script multiple times, we don't
      # want to adjust their theme.
      theme="${active_theme}"
    fi
  fi

  if [ ! -d "${DOTFILES_PATH}/themes/${theme}" ]; then
    echo "Theme '${theme}' not found, aborting!" >&2
    return 1
  fi

  # Did the theme change?
  [[ -n "${active_theme}" && "${active_theme}" != "${theme}" ]] && theme_changed=1

  # Only detect the env if we have to.
  [ -z "${OS_DISTRO:-}" ] && detect_env

  ln -fns "${DOTFILES_PATH}/themes/${theme}/btop.theme" "${HOME}/.config/btop/themes/theme.theme"
  ln -fns "${DOTFILES_PATH}/themes/${theme}/fzf.sh" "${HOME}/.config/fzf/theme.sh"
  ln -fns "${DOTFILES_PATH}/themes/${theme}/ghostty" "${HOME}/.config/ghostty/theme"
  ln -fns "${DOTFILES_PATH}/themes/${theme}/gitui.ron" "${HOME}/.config/gitui/theme.ron"
  ln -fns "${DOTFILES_PATH}/themes/${theme}/nvim.lua" "${HOME}/.config/nvim/lua/plugins/theme.lua"
  ln -fns "${DOTFILES_PATH}/themes/${theme}/tmux.conf" "${HOME}/.config/tmux/theme.conf"
  ln -fns "${DOTFILES_PATH}/themes/${theme}/eza.yml" "${HOME}/.config/eza/theme.yml"

  echo "'${theme}' is your active theme"

  # We can abort now since if we're not changing anything there's no reloading.
  [ -z "${theme_changed}" ] && return

  if [ -n "${OS_IN_WSL}" ]; then
    local windows_user=

    # shellcheck disable=SC2016
    windows_user="$({ for p in pwsh.exe '/mnt/c/Program Files/PowerShell/7/pwsh.exe' '/c/Program Files/PowerShell/7/pwsh.exe'; do if command -v "$p" >/dev/null 2>&1 || [ -x "$p" ]; then "$p" -NoProfile -NoLogo -Command '$env:UserName'; break; fi; done; } | tr -d '\r\n')"

    local WT_PATH="/mnt/c/Users/${windows_user}/AppData/Local/Packages/Microsoft.WindowsTerminal_8wekyb3d8bbwe/LocalState/settings.json"
    local SED_EXPR='s/\("\(colorScheme\|theme\)": *"\)[^"]*"/\1'"${theme}"'"/'

    # Let's make sure the path exists before replacing anything in case someone
    # removed the config entry from SYMLINKS_WSL.
    [ -e "${WT_PATH}" ] && sed -i "${SED_EXPR}" "${WT_PATH}"
  else
    killall -SIGUSR2 ghostty 2>/dev/null || true
  fi

  # Reload as many apps as we can.
  killall -SIGUSR2 btop 2>/dev/null || true
  tmux source-file "${HOME}/.config/tmux/tmux.conf" 2>/dev/null || true
}

healthcheck() {
  _info "CHECK INFORMATION AND VERSIONS"

  cat <<EOF
:: Dotfiles path:

${DOTFILES_PATH}

:: Git user (personal):

$(git config --file "${DOTFILES_PATH}/.config/git/config.user.personal" --get-regex "user.(name|email)")

:: Git user (bitbucket):

$(git config --file "${DOTFILES_PATH}/.config/git/config.user.bitbucket" --get-regex "user.(name|email)")

:: Git user (work):

$(git config --file "${DOTFILES_PATH}/.config/git/config.user.work" --get-regex "user.(name|email)")

:: tmux:

$(tmux -V)

:: Neovim:

$(mise x neovim -- nvim --version)

:: Fastfetch:

EOF

  mise x fastfetch -- fastfetch
}

install_mise() {
  _info "INSTALL MISE"

  if ! command -v mise 1>/dev/null; then
    curl https://mise.run | sh
  else
    mise self-update -y
  fi

  local shell_name=${ZSH_VERSION:+zsh}${BASH_VERSION:+bash}

  if type "${HOME}/.local/bin/mise" &>/dev/null; then
    if [[ -t 0 ]]; then
      eval "$("${HOME}/.local/bin/mise" activate "$shell_name")"
    else
      eval "$("${HOME}/.local/bin/mise" activate --shims)"
    fi
  fi

  mise settings exec_auto_install=false
  mise settings experimental=true
  mise settings fetch_remote_versions_timeout=60s
  mise settings http_timeout=60s
  mise settings idiomatic_version_file=false
  mise settings not_found_auto_install=false
  mise settings python.compile=false
  mise settings task_run_auto_install=false
  mise settings use_versions_host=false

  mise plugins install --force 1password-cli https://github.com/mise-plugins/mise-1password-cli.git
}

install_mongodb_tools() {
  _info "INSTALL OR UPDATE MONGODB TOOLS"

  "${DOTFILES_PATH}/.local/bin/install_mongodb_tools"
}

configure_docker_completion() {
  if command -v docker >/dev/null 2>&1; then
    printf "Docker command found\n"

    local completion_dir="${HOME}/.local/share/zsh/completions"
    local completion_file="${completion_dir}/_docker"

    if [ -d "${completion_dir}" ]; then
      printf "%s directory found\n" "${completion_dir}"

      if docker completion zsh >"${completion_file}" 2>/dev/null; then
        printf "Docker zsh completion script has been generated at %s\n\n" "${completion_file}"
      else
        printf "Failed to generate Docker completion script — 'docker completion zsh' command failed\n\n"
      fi
    else
      printf "%s directory not found\n\n" "${completion_dir}"
    fi
  else
    printf "Docker command not found\n\n"
  fi
}

configure_tools() {
  _info "CONFIGURE TOOLS COMPLETION"

  curl -fsSL https://raw.githubusercontent.com/eza-community/eza/refs/heads/main/completions/zsh/_eza -o "${HOME}/.local/share/zsh/completions/_eza"
  mise x fd -- fd --gen-completions=zsh >"${HOME}/.local/share/zsh/completions/_fd"
  mise x bat -- bat --completion zsh >"${HOME}/.local/share/zsh/completions/_bat"
  mise x ripgrep -- rg --generate complete-zsh >"${HOME}/.local/share/zsh/completions/_rg"

  configure_docker_completion

  printf "Completion has been configured for tools\n"
}

completed_message() {
  _info "NEXT STEPS (MAKE IT YOUR OWN)"

  cat <<EOF
Check out the README file on GitHub for any next steps:

https://github.com/sassdavid/dotfiles#-make-it-your-own

You can safely close this terminal.

The next time you open your terminal everything will be ready to go!
EOF

  if [[ -f "/tmp/jetbrainsmono.zip" && -n "${OS_IN_WSL}" ]]; then
    cat <<EOF

P.S.,

Since you're on WSL 2, please scroll up to the "INSTALL FONTS" section and
follow the few steps there to complete the installation. You only need to do
this once to install a few system fonts.
EOF
  fi
}

parse_args() {
  case "${1:-}" in
  --diff-config | -g)
    # Show a diff of your config file vs the example config file.
   local side_by_side="${2:-}"

    [ "${side_by_side}" = "--side" ] && side_by_side="--side-by-side"

    # shellcheck disable=SC2086
    delta install-config.example install-config ${side_by_side}

    exit
    ;;
  --diff | -d)
    # Show a diff of any local uncommitted or committed changes vs the target.
    #
    # Since we have fzf, let's use it to make browsing diffs a nice experience!
   local target="${2:-origin}"
   local side_by_side="${3:-}"

    # Since target is optional we need to handle only passing in --side.
    if [ "${target}" = "--side" ]; then
      target="origin"
      side_by_side="--side"
    fi

    git remote | grep -q "${target//./}" && git fetch "${target//./}"

    gd "${target}" "${side_by_side}"

    _info "CONDENSED GIT DIFF"
    GIT_PAGER="" git diff "${target}" --compact-summary

    exit
    ;;
  --new-commits | -n)
    # Show details about new commits that only exist in the target vs local.
    target="${2:-..origin}"

    git remote | grep -q "${target//./}" && git fetch --quiet "${target//./}"
    git log "${target}" --pretty="format:%C(magenta)%h %C(green)%ad %C(yellow)> %C(reset)%s" --date=short

    exit
    ;;
  --changelog | -c)
    # Show all remote commits.
    target="${2:-origin}"

    git remote | grep -q "${target}" && git fetch --quiet "${target}"
    git log "${target}" --pretty="format:%C(magenta)%h %C(green)%ad %C(yellow)> %C(reset)%s" --date=short

    exit
    ;;
  --pull | -p)
    PULL=1
    ;;
  --update | -u)
    PULL_UPDATE=1
    ;;
  --skip-system-packages | -S) ;;
  --help | -h)
    echo -e "$(
      cat <<EOF
  Usage examples:

  # Run the install script based on the local copy of your dotfiles
  ${C_GREEN}./install${C_RESET}

  # Pulls in the latest remote commits.
  ${C_GREEN}./install --pull${C_RESET}

  # Pulls in the latest remote commits and runs the install script.
  ${C_GREEN}./install --update${C_RESET}

  # Show a diff of your install-config vs the local install-config.example.
  ${C_GREEN}./install --diff-config${C_RESET}

  # The same as above but show the diff in side-by-side (split) mode.
  ${C_GREEN}./install --diff-config --side${C_RESET}

  # Show a diff of any local uncommited or committed changes vs the remote.
  ${C_GREEN}./install --diff [target]${C_RESET} (it defaults to "origin" if not supplied)

  # The same as above but show the diff in side-by-side (split) mode.
  ${C_GREEN}./install --diff --side${C_RESET}

  # Compare your currently checked out branch to your local main branch, this
  # could be helpful if you have a personalized branch and you pull updates into
  # main and now you want to compare them locally.
  ${C_GREEN}./install --diff main${C_RESET}

  # Show new remote commits that do not exist locally.
  ${C_GREEN}./install --new-commits [target]${C_RESET} (it defaults to "..origin" if not supplied)

  # Show your local commits that don't exist in the remote.
  ${C_GREEN}./install --new-commits origin..${C_RESET}

  # The same as above except compare it to your local main branch not remote.
  ${C_GREEN}./install --new-commits ..main${C_RESET}

  # Show your local commits that don't exist in the remote and new remote commits.
  ${C_GREEN}./install --new-commits origin...${C_RESET}

  # The same as above except compare it to your local main branch not remote.
  ${C_GREEN}./install --new-commits ...main${C_RESET}

  # Show a list of commits on a remote.
  ${C_GREEN}./install --changelog [target] (it defaults to "origin" if not supplied)${C_RESET}

  # Show this help menu.
  ${C_GREEN}./install --help${C_RESET}
EOF
    )"
    exit
    ;;
  *)
    [ -n "${1:-}" ] && _error "'${1}' is not a supported flag"

    ;;
  esac

  return 0
}

# Only run these when calling the script, not sourcing it.
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  [[ -n "${BOOTSTRAP}" && -z "${IN_CONTAINER}" ]] && bootstrap && exit

  parse_args "${@}"
  detect_env
  warn_root
  update_dotfiles "${@}"

  [ -n "${PULL}" ] && exit

  check_prereqs
  create_initial_dirs
  install_mise
  install_packages
  clone_dotfiles
  install_fonts
  install_mongodb_tools
  install_zsh_plugins
  create_symlinks
  configure_system_configs
  configure_home_configs
  configure_shell
  configure_git
  configure_tools
  install_programming_languages
  install_tmux_plugins
  install_nvim_plugins
  set_theme "${@}"
  healthcheck
  completed_message
fi
