#!/usr/bin/env bash
# bashsupport disable=BP5008,BP5006,BP5001,BP5007
# Usage:
#   ./install          # Clone my dotfiles
#   DEBUG=1 ./install  # Copy the local dotfiles directory instead of cloning
#
#   # Customize which dotfiles URL to clone from
#   DOTFILES_URL="https://github.com/example/dotfiles" ./install

set -o errexit

SKIP_SYSTEM_PACKAGES="${1:-}"

ARCH_PACKAGES="
  aspell
  base
  base-devel
  bc
  curl
  fastfetch
  git
  gnupg
  htop
  inotify-tools
  less
  man-db
  man-pages
  openbsd-netcat
  pacman-contrib
  pwgen
  rsync
  tmux
  unzip
  wget
  whois
  wl-clipboard
  zip
  zsh
"

APT_PACKAGES="
  aspell
  bc
  build-essential
  curl
  git
  gnupg
  htop
  inotify-tools
  iproute2
  netcat-openbsd
  pwgen
  rsync
  tmux
  unzip
  wget
  whois
  wl-clipboard
  xz-utils
  zip
  zsh
"

MISE_BASE_PACKAGES="
  cosign
  slsa-verifier
  usage
"

MISE_PACKAGES="
  1password-cli
  amazon-ecr-credential-helper
  argocd
  awscli
  bat
  curlie
  dua
  eksctl
  eza
  fd
  fzf
  gdu
  gitui
  helm
  hyperfine
  jq
  k9s
  kubectl
  maven
  neovim
  pre-commit
  ripgrep
  terraform
  terraform-docs
  terragrunt
  tflint
  uv
  yq
  zoxide
"

NAME=
EMAIL=

OS_TYPE="$(uname | tr "[:upper:]" "[:lower:]")"
OS_DISTRO=
OS_IN_WSL=

DOTFILES_URL="${DOTFILES_URL:-https://github.com/sassdavid/dotfiles}"
DOTFILES_PATH="${DOTFILES_PATH:-"${HOME}/dotfiles"}"

# -----------------------------------------------------------------------------
# Helper functions
# -----------------------------------------------------------------------------

_error() {
  local message="${1:-}"

  printf "\e[31;1mERROR:\e[0m %s\n\n" "${message}" >&2
  exit 1
}

_info() {
  local message="${1:-}"
  printf "\n\n\e[36;1m%s:\e[0m\n\n" "${message}"
}

_no_system_packages() {
  cat <<EOF
System package installation isn't supported with your distro (${OS_DISTRO})

Please install any comparable packages on your own, you can view the list at:

    https://github.com/sassdavid/dotfiles/blob/master/install

Then re-run this script and explicitly skip installing system packages:

    bash <(curl -sS https://raw.githubusercontent.com/sassdavid/dotfiles/main/install) --skip-system-packages
EOF

  exit 1
}

_install_packages_arch() {
  # shellcheck disable=SC2086
  sudo pacman -Syu --noconfirm ${ARCH_PACKAGES}
}

_install_packages_apt() {
  sudo add-apt-repository -y ppa:git-core/ppa

  # shellcheck disable=SC2086
  sudo apt-get update && sudo apt-get upgrade -y && sudo apt-get install -y ${APT_PACKAGES}

  sudo apt-get clean && sudo rm -rf /var/lib/apt/lists /var/cache/apt/archives

  # Install packages manually since they don't exist elsewhere.

  # fastfetch, Debian 13 / Ubuntu 26.04 LTS will have it in apt by default.
  echo
  curl -fsSL https://github.com/fastfetch-cli/fastfetch/releases/latest/download/fastfetch-linux-amd64.deb -o /tmp/fastfetch.deb
  sudo dpkg -i "${_}"
  rm "${_}"
}

_display_packages() {
  if [ "${OS_TYPE}" == "linux" ]; then
    if [ "${OS_DISTRO}" == "arch" ]; then
      echo "${ARCH_PACKAGES}"
    elif [ "${OS_DISTRO}" == "debian" ]; then
      echo "${APT_PACKAGES}"
    fi
    echo "${MISE_BASE_PACKAGES}"
    echo "${MISE_PACKAGES}"
  fi
}

# -----------------------------------------------------------------------------
# Main functions
# -----------------------------------------------------------------------------

detect_env() {
  case "${OS_TYPE}" in
  linux)
    # bashsupport disable=BP5006
    if [ -r /etc/os-release ]; then
      # shellcheck disable=SC1091
      OS_DISTRO="$(. /etc/os-release && echo "${ID_LIKE:-${ID}}")"

      # Technically ID_LIKE can have a space separated list of distros but
      # we really only care that we have a Debian based system where apt is
      # available to use.
      [[ "${OS_DISTRO}" =~ (ubuntu|debian) ]] && OS_DISTRO="debian"
    fi

    # Only fully support these Linux distros.
    if [[ -z "${OS_DISTRO}" || ! "arch ubuntu debian raspbian" =~ ${OS_DISTRO} ]]; then
      [ -z "${SKIP_SYSTEM_PACKAGES}" ] && _no_system_packages
    fi

    # Are we in WSL?
    if grep -q "\-WSL2" /proc/version; then
      OS_IN_WSL=1
    fi

    # Adjust packages depending on which display server is in use.
    if [[ -z "${WAYLAND_DISPLAY}" ]]; then
      APT_PACKAGES="${APT_PACKAGES//wl-clipboard/xclip}"
      ARCH_PACKAGES="${ARCH_PACKAGES//wl-clipboard/xclip}"
    fi

    ;;
  *)
    _error "'${OS_TYPE}' is not supported"

    ;;
  esac
}

warn_root() {
  # Root will have an effective uid of 0, but it's ok if we're in a container.
  [[ "${EUID}" != 0 || -n "${IN_CONTAINER}" ]] && return 0

  cat <<EOF
Here are details about this user:

$(id)

EOF

  local msg="as root"
  [[ -n "${SUDO_USER}" ]] && msg="with sudo as ${SUDO_USER}"

  while true; do
    read -rp "This script is meant to run as a non-root user, are you sure you want to run this ${msg}? (y/n) " yn
    case "${yn}" in
    [Yy]*) break ;;
    [Nn]*) exit ;;
    *) printf "Please answer y or n\n\n" ;;
    esac
  done
}

check_prereqs() {
  _info "CHECKING SYSTEM COMPATABILITY"

  local missing_packages=()

  if ! command -v "sudo" 1>/dev/null; then missing_packages+=("sudo"); fi

  if [[ -z "${missing_packages[*]}" ]]; then
    echo "Everything is good to go"
    return 0
  fi

  cat <<EOF
This script is going to switch to the root user to install sudo then the rest
of the script will run as your user and use sudo as needed.

EOF

  case "${OS_DISTRO}" in
  arch)
    su -c "pacman -Syu --noconfirm ${missing_packages[*]}"
    ;;
  debian)
    su -c "apt-get update && apt-get install -y ${missing_packages[*]}"
    ;;
  *) ;;
  esac
}

create_initial_dirs() {
  mkdir -p "${HOME}/.config/tmux/plugins" "${HOME}/.config/git" "${HOME}/.config/zsh" "${HOME}/.cache/zsh" \
    "${HOME}/.local/bin" "${HOME}/.local/share" "${HOME}/.config/gitalias" \
    "${HOME}/.local/share/zsh/completions" "${HOME}/.local/state" "${HOME}/.aws" \
    "${HOME}/.kube"
}

install_packages() {
  _info "INSTALL PACKAGES"

  if [ -n "${SKIP_SYSTEM_PACKAGES}" ]; then
    echo "Skipping, you've chosen not to or your distro isn't fully supported"
    return
  fi

  cat <<EOF
If you choose y, all of the system packages below will be installed:

$(_display_packages)


If you choose no, the above packages will not be installed and this script
will exit. This gives you a chance to edit the list of packages if you want
to adjust them.

EOF

  while true; do
    read -rp "Do you want to install the above packages? (y/n) " yn
    case "${yn}" in
    [Yy]*)
      if [ "${OS_TYPE}" == "linux" ]; then
        if [ "${OS_DISTRO}" == "arch" ]; then
          _install_packages_arch
        elif [ "${OS_DISTRO}" == "debian" ]; then
          _install_packages_apt
        fi
      fi

      break
      ;;
    [Nn]*) exit ;;
    *) printf "Please answer y or n\n\n" ;;
    esac
  done

}

clone_or_update_dotfiles() {
  _info "CLONE OR UPDATE DOTFILES"

  local local_zprofile="${HOME}/.config/zsh/.zprofile.local"

  if [ -f "${local_zprofile}" ]; then
    # shellcheck disable=SC1090
    . "${local_zprofile}"
  fi

  local dotfiles_path
  read -rep "Where do you want to clone these dotfiles to [${DOTFILES_PATH}]? " dotfiles_path
  echo

  [[ -z "${dotfiles_path}" ]] && dotfiles_path="${DOTFILES_PATH}"

  # bashsupport disable=BP5006
  DOTFILES_PATH="${dotfiles_path//\~/"${HOME}"}"

  # This is used to locally develop the install script.
  if [ "${DEBUG}" == "1" ]; then
    if [ "${PWD}" != "${DOTFILES_PATH}" ]; then
      cp -R "${PWD}/." "${DOTFILES_PATH}"

      # Ensure the containerized environment starts fresh.
      if [[ -n "${IN_CONTAINER}" ]]; then
        rm \
          "${DOTFILES_PATH}/.config/zsh/.zsh_history" \
          "${DOTFILES_PATH}/.config/zsh/.aliases.local" \
          "${DOTFILES_PATH}/.config/zsh/.zprofile.local" \
          "${DOTFILES_PATH}/.config/zsh/.zshrc.local" \
          "${DOTFILES_PATH}/.config/git/config.local"
      fi
    fi

    printf "They've been copied to '%s'\n" "${DOTFILES_PATH}"
    return
  fi

  if [ -e "${DOTFILES_PATH}" ]; then
    # Let's get the latest updates.
    git -C "${DOTFILES_PATH}" pull
  else
    mkdir -p "$(dirname "${DOTFILES_PATH}")"
    git clone "${DOTFILES_URL}" "${DOTFILES_PATH}"
  fi
}

install_zsh_plugins() {
  _info "INSTALL ZSH PLUGINS"

  "${DOTFILES_PATH}/.local/bin/update-zsh-plugins"
}

create_symlinks() {
  _info "CREATE SYMLINKS"

  local symlinks=(
    "ln -fs \"${DOTFILES_PATH}/.zshenv\" \"${HOME}/.zshenv\""
    "ln -fs \"${DOTFILES_PATH}/.config/zsh/.zshrc\" \"${HOME}/.config/zsh/.zshrc\""
    "ln -fs \"${DOTFILES_PATH}/.config/zsh/.zshrc.local\" \"${HOME}/.config/zsh/.zshrc.local\""
    "ln -fs \"${DOTFILES_PATH}/.config/zsh/.zprofile\" \"${HOME}/.config/zsh/.zprofile\""
    "ln -fs \"${DOTFILES_PATH}/.config/zsh/.zprofile.local\" \"${HOME}/.config/zsh/.zprofile.local\""
    "ln -fs \"${DOTFILES_PATH}/.config/zsh/.aliases\" \"${HOME}/.config/zsh/.aliases\""
    "ln -fs \"${DOTFILES_PATH}/.config/zsh/.aliases.local\" \"${HOME}/.config/zsh/.aliases.local\""
    "ln -fs \"${DOTFILES_PATH}/.config/tmux/tmux.conf\" \"${HOME}/.config/tmux/tmux.conf\""
    "ln -fs \"${DOTFILES_PATH}/.config/zsh/themes\" \"${HOME}/.config/zsh/themes\""
    "ln -fs \"${DOTFILES_PATH}/.config/tmux/themes\" \"${HOME}/.config/tmux/themes\""
    "ln -fs \"${DOTFILES_PATH}/.config/git/config\" \"${HOME}/.config/git/config\""
    "ln -fs \"${DOTFILES_PATH}/.config/git/config.user.personal\" \"${HOME}/.config/git/config.user.personal\""
    "ln -fs \"${DOTFILES_PATH}/.config/git/config.user.bitbucket\" \"${HOME}/.config/git/config.user.bitbucket\""
    "ln -fs \"${DOTFILES_PATH}/.config/git/config.user.work\" \"${HOME}/.config/git/config.user.work\""
    "ln -fs \"${DOTFILES_PATH}/.config/gitui\" \"${HOME}/.config/gitui\""
    "ln -fs \"${DOTFILES_PATH}/.config/nvim\" \"${HOME}/.config/nvim\""
    "ln -fs \"${DOTFILES_PATH}/.local/bin/\"* \"${HOME}/.local/bin/\""
    "ln -fs \"/c/Windows/System32/cmd.exe\" \"${HOME}/.local/bin/cmd.exe\""
  )

  local symlinks_system=()

  if [ -n "${OS_IN_WSL}" ]; then
    symlinks_system+=("sudo ln -fs \"${DOTFILES_PATH}/etc/wsl.conf\" \"/etc/wsl.conf\"")
  fi

  if [ "${OS_DISTRO}" = "arch" ]; then
    symlinks_system+=("sudo ln -fs \"${DOTFILES_PATH}/etc/pacman.d/01-options.conf\" \"/etc/pacman.d/01-options.conf\"")

    if [ -f "etc/pacman.d/02-ignore.conf" ]; then
      symlinks_system+=("sudo ln -fs \"${DOTFILES_PATH}/etc/pacman.d/02-ignore.conf\" \"/etc/pacman.d/02-ignore.conf\"")
    else
      sudo rm -f "/etc/pacman.d/02-ignore.conf"
    fi
  fi

  printf -- "-------------------------------------------------------------------------------\n\n"

  local link
  for link in "${symlinks[@]}"; do
    echo "${link}"
  done

  for link in "${symlinks_system[@]}"; do
    echo "${link}"
  done

  cat <<EOF

-------------------------------------------------------------------------------

A potentially destructive action is about to happen. The above directories and
files are going to get forcefully symlinked if you type y in the prompt below.

What does that mean?

Any config files you have on the right hand side of the paths are going to get
overwritten with the files that come with these dotfiles (left side).

Without these symlinks, these dotfiles will not work. If you plan to type y
and have existing files now would be a good time to back them up.

EOF

  while true; do
    read -rep "Ready to continue? Enter y to apply them all or n to skip (y/n) " yn
    case "${yn}" in
    [Yy]*)
      # We're being extra careful here to only delete symlinks if they exist.
      # Technically rm -f would work but that could delete real files potentially.
      [ -L "${HOME}/.config/zsh/themes" ] && rm "${HOME}/.config/zsh/themes"
      [ -L "${HOME}/.config/tmux/themes" ] && rm "${HOME}/.config/tmux/themes"
      [ -L "${HOME}/.config/gitui" ] && rm "${HOME}/.config/gitui"
      [ -L "${HOME}/.config/nvim" ] && rm "${HOME}/.config/nvim"

      for link in "${symlinks[@]}"; do
        eval "${link}"
      done

      for link in "${symlinks_system[@]}"; do
        eval "${link}"
      done

      break
      ;;
    [Nn]*)

      break
      ;;
    *) echo "Please answer y or n" ;;
    esac
  done
}

configure_system_configs() {
  _info "CONFIGURE SYSTEM CONFIGS"

  if [ "${OS_DISTRO}" = "arch" ]; then
    local etc_pacman_conf_path="/etc/pacman.conf"
    if ! grep -q "Include = /etc/pacman\.d/\*\.conf" "${etc_pacman_conf_path}" 2>/dev/null; then
      printf "\nInclude = /etc/pacman.d/*.conf\n" | sudo tee --append "${etc_pacman_conf_path}" 1>/dev/null
    fi
  fi

  echo "Everything that required updating was updated"
}

configure_shell() {
  _info "CONFIGURE SHELL (ZSH)"

  local local_files=(".zshrc.local" ".zprofile.local" ".aliases.local")
  local original_dotfiles_path="${DOTFILES_PATH}"

  local file
  for file in "${local_files[@]}"; do
    local file_path="${HOME}/.config/zsh/${file}"

    if [ ! -f "${file_path}" ]; then
      printf "# shellcheck shell=bash\n\n# Any settings defined here are gitignored.\n" >"${file_path}"
    fi
  done

  local zprofile_path="${DOTFILES_PATH}/.config/zsh/.zprofile.local"
  local aliases_path="${DOTFILES_PATH}/.config/zsh/.aliases.local"

  if ! grep -q "^export DOTFILES_PATH=.*$" "${zprofile_path}" 2>/dev/null; then
    printf '\nexport DOTFILES_PATH="%s"\n' "${DOTFILES_PATH}" >>"${zprofile_path}"
  fi

  # Are we in WSL 2?
  if [ -n "${OS_IN_WSL}" ]; then
    if ! grep -q "^export GIT_SSH=.*$" "${zprofile_path}" 2>/dev/null; then
      local display
      display=$(
        cat <<'EOF'
# Configure OpenSSH in order to 1password ssh will be usable
export GIT_SSH="/c/Program\ Files/OpenSSH/ssh.exe"
export GIT_SSH_COMMAND="/c/Program\ Files/OpenSSH/ssh.exe"
EOF
      )

      printf "\n%s" "${display}" >>"${zprofile_path}"
    fi

    if ! grep -q "^alias ssh=.*$" "${aliases_path}" 2>/dev/null; then
      local custom_aliases
      custom_aliases=$(
        cat <<'EOF'
alias ssh="/c/Program\ Files/OpenSSH/ssh.exe"
alias ssh-add="/c/Program\ Files/OpenSSH/ssh-add.exe"
alias ssh2="/usr/bin/ssh"

# This is specific to WSL 2. If the WSL 2 VM goes rogue and decides not to free
# up memory, this command will free your memory after about 20-30 seconds.
#   Details: https://github.com/microsoft/WSL/issues/4166#issuecomment-628493643
alias drop_cache="sudo sh -c \"echo 3 >'/proc/sys/vm/drop_caches' && swapoff -a && swapon -a && printf '\n%s\n' 'Ram-cache and Swap Cleared'\""
EOF
      )

      printf "\n%s" "${custom_aliases}" >>"${aliases_path}"
    fi
  fi

  [ "${SHELL: -3}" != "zsh" ] && chsh -s "/usr/bin/zsh"

  # shellcheck disable=SC1091
  . "${HOME}/.config/zsh/.zprofile"

  # Given the above line sets this env var if it's defined, this ensures we
  # always use the value that was set when running this script. This is mainly
  # to make testing this script easier in Docker since the .local files are
  # volume mounted and this value will be different in Docker.
  # bashsupport disable=BP5006
  DOTFILES_PATH="${original_dotfiles_path}"

  echo "It has been configured in '${HOME}/.config/zsh/'"
}

ask_for_identity() {
  local identity="$1"
  _info "ASKING FOR NAME AND EMAIL FOR '${identity^^}'"

  local name email

  while true; do
    printf "Full name for '%s' (e.g., Dade Murphy): " "$identity"
    read -r name
    [[ $name =~ [^[:space:]]+ ]] && break
    printf "Please enter a valid name\n\n"
  done

  while true; do
    printf "Email for '%s' (e.g., zerocool@example.com): " "$identity"
    read -r email
    [[ $email =~ .+@.+ ]] && break
    printf "Please enter a valid email\n\n"
  done

  NAME="$name"
  EMAIL="$email"
}

configure_git() {
  _info "CONFIGURE GIT"

  local config_dir="${DOTFILES_PATH}/.config/git"

  declare -A templates=(
    ["personal"]="full"
    ["bitbucket"]="full"
    ["work"]="minimal"
  )

  local identity
  for identity in "${!templates[@]}"; do
    local path="${config_dir}/config.user.${identity}"

    if [ -f "$path" ]; then
      printf "Skipped %s (already exists)\n" "$path"
      continue
    fi

    ask_for_identity "$identity"

    case "${templates[$identity]}" in
      full)
        cat > "$path" <<EOF
[user]
  name = ${NAME}
  email = ${EMAIL}
  # Uncomment the options below to auto-sign your git commits / tags using SSH.
  #signingkey = ${EMAIL}

#[commit]
#  gpgsign = true

#[tag]
#  gpgSign = true

#[gpg]
#  format = ssh

#[gpg "ssh"]
#  program = ""
EOF
        ;;
      minimal)
        cat > "$path" <<EOF
[user]
  name = ${NAME}
  email = ${EMAIL}
EOF
        ;;
    esac

    printf "Created %s\n" "$path"
  done

  curl -fsSL https://raw.githubusercontent.com/GitAlias/gitalias/main/gitalias.txt -o "${HOME}/.config/gitalias/gitalias.txt"
  printf "\ngitalias configured\n"
}

install_rust() {
  _info "INSTALL OR UPDATE RUST"

  local rust_lang_home="${HOME}/rust-lang"
  local cargo_home="${rust_lang_home}/.cargo"
  local cargo_bin_home="${cargo_home}/bin"
  local rustup="${cargo_bin_home}/rustup"

  # Install rustup if not already installed
  if [ ! -x "${rustup}" ]; then
    printf "Rust not found, installing...\n"
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --no-modify-path
  else
    printf "Rust already installed, updating...\n"
    "${rustup}" self update
    "${rustup}" update
  fi

  "${rustup}" completions zsh >"${HOME}/.local/share/zsh/completions/_rustup"
  "${rustup}" completions zsh cargo >"${HOME}/.local/share/zsh/completions/_cargo"
}

install_programming_languages() {
  _info "INSTALL PROGRAMMING LANGUAGES"

  printf "Installing Node...\n\n"
  if command -v "${HOME}/.local/share/mise/shims/node" 1>/dev/null; then
    echo "Skipping Node, it's already installed, run 'mise upgrade node --bump' to upgrade"
  else
    mise install node@20
    mise use --global node@22
  fi

  printf "\nInstalling Python...\n\n"
  if command -v "${HOME}/.local/share/mise/shims/python3" 1>/dev/null; then
    echo "Skipping Python, it's already installed, run 'mise upgrade python --bump' to upgrade"
  else
    mise use --global python@3.13
  fi

  printf "\nInstalling Go...\n\n"
  if command -v "${HOME}/.local/share/mise/shims/go" 1>/dev/null; then
    echo "Skipping Go, it's already installed, run 'mise upgrade go --bump' to upgrade"
  else
    mise use --global go
  fi

  printf "\nInstalling Java...\n\n"
  if command -v "${HOME}/.local/share/mise/shims/java" 1>/dev/null; then
    echo "Skipping Java, it's already installed, run 'mise upgrade java --bump' to upgrade"
  else
    mise use --global java@corretto-17
  fi

  install_rust
}

install_tmux_plugins() {
  _info "INSTALL TMUX PLUGINS"

  local plugin_path="${HOME}/.config/tmux/plugins"
  local tpm_path="${plugin_path}/tpm"

  rm -rf "${tpm_path}"
  git clone --depth 1 https://github.com/tmux-plugins/tpm "${tpm_path}"

  "${tpm_path}/bin/install_plugins"
}

install_nvim_plugins() {
  _info "INSTALL NEOVIM PLUGINS"

  mise x neovim -- nvim +q

  echo "They've been installed"
}

healthcheck() {
  _info "CHECK INFORMATION AND TOOL VERSIONS"

  cat <<EOF
:: Dotfiles path:

${DOTFILES_PATH}

:: Git user:

$(git config --get-regex "user.(name|email)")

:: tmux:

$(tmux -V)

:: Neovim:

$(mise x neovim -- nvim --version)

:: Programming languages:

Node $(mise x node -- node --version)
$(mise x python -- python --version)

:: Fastfetch:

EOF

  fastfetch
}

install_and_configure_mise() {
  _info "INSTALL MISE"

  curl https://mise.run | sh

  local shell_name=${ZSH_VERSION:+zsh}${BASH_VERSION:+bash}

  if type "${HOME}/.local/bin/mise" &>/dev/null; then
    if [[ -t 0 ]]; then
      eval "$("${HOME}/.local/bin/mise" activate "$shell_name")"
    else
      eval "$("${HOME}/.local/bin/mise" activate --shims)"
    fi
  fi

  mise settings exec_auto_install=false
  mise settings experimental=true
  mise settings fetch_remote_versions_timeout=60s
  mise settings http_timeout=60s
  mise settings idiomatic_version_file=false
  mise settings not_found_auto_install=false
  mise settings task_run_auto_install=false
  mise settings use_versions_host=false

  mise plugins install --force 1password-cli https://github.com/mise-plugins/mise-1password-cli.git
}

install_mongodb_tools() {
  _info "INSTALL OR UPDATE MONGODB TOOLS"

  "${DOTFILES_PATH}/.local/bin/install_mongodb_tools"
}

configure_docker_completion() {
  _info "CONFIGURE DOCKER COMPLETION"

  if command -v docker >/dev/null 2>&1; then
    printf "Docker command found\n"

    local completion_dir="${HOME}/.local/share/zsh/completions"
    local completion_file="${completion_dir}/_docker"

    if [ -d "${completion_dir}" ]; then
      printf "%s directory found\n" "${completion_dir}"

      if docker completion zsh >"${completion_file}" 2>/dev/null; then
        printf "Docker zsh completion script has been generated at %s\n\n" "${completion_file}"
      else
        printf "Failed to generate Docker completion script â€” 'docker completion zsh' command failed\n\n"
      fi
    else
      printf "%s directory not found\n\n" "${completion_dir}"
    fi
  else
    printf "Docker command not found\n\n"
  fi
}

# shellcheck disable=SC2086
install_and_configure_tools (){
  _info "INSTALL TOOLS"

  mise use --global ${MISE_BASE_PACKAGES}
  mise use --global ${MISE_PACKAGES}

  install_mongodb_tools

  curl -LSfs https://raw.githubusercontent.com/eza-community/eza/refs/heads/main/completions/zsh/_eza -o "${HOME}/.local/share/zsh/completions/_eza"
  mise x fd -- fd --gen-completions=zsh >"${HOME}/.local/share/zsh/completions/_fd"
  mise x bat -- bat --completion zsh >"${HOME}/.local/share/zsh/completions/_bat"
  mise x ripgrep -- rg --generate complete-zsh >"${HOME}/.local/share/zsh/completions/_rg"

  configure_docker_completion
}

completed_message() {
  _info "NEXT STEPS (MAKE IT YOUR OWN)"

  cat <<EOF
Check out the README file on GitHub for any next steps:

https://github.com/sassdavid/dotfiles#-make-it-your-own

You can safely close this terminal.

The next time you open your terminal everything will be ready to go!
EOF
}

detect_env
warn_root
check_prereqs
create_initial_dirs
install_packages
clone_or_update_dotfiles
install_zsh_plugins
create_symlinks
configure_system_configs
configure_shell
configure_git
install_and_configure_mise
install_and_configure_tools
install_programming_languages
install_tmux_plugins
install_nvim_plugins
healthcheck
completed_message
